#Перспективы развития архитектуры операционных систем при использовании контейнерной виртуализации
//на примере Docker

##Введение
Виртуализа́ция — предоставление набора вычислительных ресурсов или их логического объединения, абстрагированное от аппаратной реализации, и обеспечивающее при этом логическую изоляцию друг от друга вычислительных процессов, выполняемых на одном физическом ресурсе.

Примером использования виртуализации является возможность запуска нескольких операционных систем на одном компьютере: при том каждый из экземпляров таких гостевых операционных систем работает со своим набором логических ресурсов (процессорных, оперативной памяти, устройств хранения), предоставлением которых из общего пула, доступного на уровне оборудования, управляет хостовая операционная система — гипервизор. Также могут быть подвергнуты виртуализации сети передачи данных, сети хранения данных, платформенное и прикладное программное обеспечение.

Виртуализация приложений — процесс использования приложения, преобразованного из требующего установки в операционную систему в не требующее (требуется только запустить). Для виртуализации приложений программное обеспечение виртуализатора определяет при установке виртуализуемого приложения, какие требуются компоненты ОС, и эмулирует их, таким образом, создаётся необходимая специализированная среда для конкретно этого виртуализируемого приложения и, тем самым, обеспечивается изолированность работы этого приложения. Для создания виртуального приложения виртуализируемое помещается в контейнер, оформленный, как правило, в виде папки. При запуске виртуального приложения запускается виртуализируемое приложение и контейнер, являющийся для него рабочей средой. Рабочая среда запускается и предоставляет локальные ранее созданные ресурсы, которое включает в себя ключи реестра, файлы и другие компоненты, необходимые для запуска и работы приложения. Такая виртуальная среда работает как прослойка между приложением и операционной системой, что позволяет избежать конфликтов между приложениями. Виртуализацию приложений обеспечивают, например, программы Citrix XenApp, SoftGrid и VMware ThinApp.

Достоинства:

* изолированность исполнения приложений: отсутствие несовместимостей и конфликтов;
* каждый раз в первозданном виде: не загромождается реестр, нет конфигурационных файлов — необходимо для сервера;
* меньшие ресурсозатраты по сравнению с эмуляцией всей операционной системы.

![Иллюстрация на тему возможных конфигураций контейнеров](http://img.scoop.it/tImVj_1Pbqv0HJDyMWTmBbnTzqrqzN7Y9aBZTaXoQ8Q=)  

##Основная часть
###Виды виртуализации
####Программная виртуализация
#####Динамическая трансляция
При динамической (бинарной) трансляции проблемные команды гостевой операционной системы перехватываются гипервизором. После того как эти команды заменяются на безопасные, происходит возврат управления гостевой системе.  

#####Паравиртуализация
Паравиртуализация — техника виртуализации, при которой гостевые операционные системы подготавливаются для исполнения в виртуализированной среде, для чего их ядро незначительно модифицируется. Операционная система взаимодействует с программой гипервизора, который предоставляет ей гостевой API, вместо использования напрямую таких ресурсов, как таблица страниц памяти.  
Метод паравиртуализации позволяет добиться более высокой производительности, чем метод динамической трансляции.  
Метод паравиртуализации применим лишь в том случае, если гостевые операционные системы имеют открытые исходные коды, которые можно модифицировать согласно лицензии, или же гипервизор и гостевая операционная система разработаны одним производителем с учётом возможности паравиртуализации гостевой системы (хотя при условии того, что под гипервизором может быть запущен гипервизор более низкого уровня, то и паравиртуализации самого гипервизора).

######Встроенная виртуализация
Преимущества:

* Совместное использование ресурсов несколькими гостевыми операционными системами (каталоги, принтеры и так далее).  
* Удобство интерфейса для окон приложений из разных систем (перекрывающиеся окна приложений, одинаковая минимизация окон, как в хост-системе).  
* При тонкой настройке на аппаратную платформу производительность мало отличается от оригинальной операционной системы. Быстрое переключение между системами (менее одной секунды).  
* Простая процедура обновления гостевой операционной системы.  
* Двухсторонняя виртуализация (приложения одной системы запускаются в другой и наоборот).  

####Аппаратная виртуализация
Преимущества:

* Упрощение разработки программных платформ виртуализации за счет предоставления аппаратных интерфейсов управления и поддержки виртуальных гостевых систем. Это уменьшает трудоемкость и время на разработку систем виртуализации.  
* Возможность увеличения быстродействия платформ виртуализации. Управление виртуальными гостевыми системами осуществляет напрямую небольшой промежуточный слой программного обеспечения, гипервизор, что дает увеличение быстродействия.  
* Улучшается защищённость, появляется возможность переключения между несколькими запущенными независимыми платформами виртуализации на аппаратном уровне. Каждая из виртуальных машин может работать независимо, в своем пространстве аппаратных ресурсов, полностью изолированно друг от друга. Это позволяет устранить потери быстродействия на поддержание хостовой платформы и увеличить защищенность.  
* Гостевая система становится не привязана к архитектуре хостовой платформы и к реализации платформы виртуализации. Технология аппаратной виртуализации делает возможным запуск 64-битных гостевых систем на 32-битных хостовых системах (с 32-битными средами виртуализации на хостах).  


####Виртуализация на уровне операционной системы
Виртуализация на уровне операционной системы позволяет запускать изолированные и безопасные виртуальные машины на одном физическом узле, но не позволяет запускать операционные системы с ядрами, отличными от типа ядра базовой операционной системы. При виртуализации на уровне операционной системы не существует отдельного слоя гипервизора. Вместо этого сама хостовая операционная система отвечает за разделение аппаратных ресурсов между несколькими виртуальными машинами и поддержку их независимости друг от друга.  

###Принципы разделения пространств (namespaces, cgroups)
####Namespaces
Согласно официальной документации ядра Linux, размещённой на сайте kernel.org,  

    A namespace wraps a global system resource in an abstraction that
    makes it appear to the processes within the namespace that they have
    their own isolated instance of the global resource.  Changes to the
    global resource are visible to other processes that are members of
    the namespace, but are invisible to other processes.  One use of
    namespaces is to implement containers.

    Linux provides the following namespaces:

        Namespace   Constant          Isolates
        Cgroup      CLONE_NEWCGROUP   Cgroup root directory
        IPC         CLONE_NEWIPC      System V IPC, POSIX message queues
        Network     CLONE_NEWNET      Network devices, stacks, ports, etc.
        Mount       CLONE_NEWNS       Mount points
        PID         CLONE_NEWPID      Process IDs
        User        CLONE_NEWUSER     User and group IDs
        UTS         CLONE_NEWUTS      Hostname and NIS domain name

То есть, упрощённо, namespaces позволяют ограничивать видимость некоторых глобальных ресурсов программами. Например, идентификаторов процессов (PID), что позволяет разделять области видимости для процессов, которым не требуется больше: к примеру, некоторый пакетный менеджер не требует для нормальной работы доступа к запущенному веб-браузеру. Но, в случае использования злоумышленником некоторой уязвимости, он мог бы получить к нему доступ.  
####Cgroups
Cgroups похожи на namespaces по описанию, но относятся больше к физическим ресурсам компьютера.
Согласно документации,  

    A cgroup is a collection of processes that are bound to a set of
    limits or parameters defined via the cgroup filesystem.

    A subsystem is a kernel component that modifies the behavior of the
    processes in a cgroup.  Various subsystems have been implemented,
    making it possible to do things such as limiting the amount of CPU
    time and memory available to a cgroup, accounting for the CPU time
    used by a cgroup, and freezing and resuming execution of the
    processes in a cgroup.  Subsystems are sometimes also known as
    resource controllers (or simply, controllers).

    The cgroups for a subsystem are arranged in a hierarchy.  This
    hierarchy is defined by creating, removing, and renaming
    subdirectories within the cgroup filesystem.  At each level of the
    hierarchy, attributes (e.g., limits) can be defined; these attributes
    may govern or propagate to child cgroups and and their descendants in
    the hierarchy.

Таким образом, данная технология позволяет ограничить используемые процессом (или группой процессов) ресурсы вплоть до полной остановки группы (контроллер _freezer_), включая её иерархических "потомков", сообщить приложению меньшее количество оперативной памяти/процессорных ядер процессора, чем на самом деле присутствует в системе, тем самым оставив большее количество ресурсов прочим приложениям, и так далее (см. `man 7 cgroups`, раздел subsystems, для большей информации)

###Принципы контейнерной виртуализации
    Контейнер – это метафора. В морских и железнодорожных перевозках буквальные контейнеры 
    используются потому, что благодаря стандартизованной форме и размеру их удобно складывать 
    большими штабелями. Точно так же виртуальный контейнер позволяет взять приложение (это может 
    быть почтовый клиент, блогерская платформа, что угодно) и все необходимые для него 
    инструменты и упаковать в стандартную виртуальную «коробку». Затем такая коробка загружается 
    на сервер или дата-центр, будь то собственный или сторонний, и ее содержимое везде работает 
    абсолютно одинаково вне зависимости от среды, инфраструктуры и прочих условий. Работа 
    приложения становится самодостаточной и полностью отделяется от окружающей реализации. 
    Отсюда название и «контейнер» – от self-contained, «самодостаточный».
![Иллюстрация на тему возможных применений контейнеров](http://image.slidesharecdn.com/dockerwithopenstack-141022075719-conversion-gate02/95/docker-with-openstack-11-638.jpg?cb=1413964733)  

Контейнерная виртуализация относится к виртуализации на уровне операционной системы и поэтому требует поддержки данной технологии ядром хост-ОС. В настоящий момент лучше всего для этого подходит при достаточной распространённости и известности ядро GNU/Linux благодаря поддержке описанных выше технологий.  

###Docker как наиболее известная система управления контейнерами
В настоящий момент данная отрасль довольно активно развивается. Существует ПО для создания и управления контейнерами: например, OpenVZ и LXC.  
Наиболее известен Docker, про который также говорится "Docker: container revolution".  

    Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в 
    среде виртуализации на уровне операционной системы, например LXC. Позволяет «упаковать» 
    приложение со всем его окружением и зависимостями в контейнер, который может быть перенесён 
    на любой Linux-системе с поддержкой cgroups в ядре, а также предоставляет среду по 
    управлению контейнерами.

    Разрабатывается и поддерживается одноимённой компанией-стартапом, распространяется как 
    свободное программное обеспечение под лицензией Apache 2.0. Написан на языке Go.

Docker позиционируется как инструмент для упрощения разработки, поддержки и конфигурации программного обеспечения. Плюсы использования Docker:

  * *Размер*: Виртуальные машины занимают довольно большое количество дискового пространства, что делает их не очень удобными для транспортировки и хранения.
  * *Быстродействие*: Запуск виртуальной машины требует значительных ресурсов оперативной памяти и процессора, что делает их непрактичными во многих сценариях использования.
  * *Переносимость*: Разнообразные окружения виртуальных машин не очень хорошо взаимодействуют между собой. Несмотря на существование средств конвертации, они довольно ограниченны и добавляют ещё большее использование ресурсов.
  * *Аппаратно-ориентированность*: Виртуальные машины были разработаны не для разработчиков, а для механизаторов _(как это перевести? - прим. авт.)_. В результате, они предлагают довольно скудный инструментарий для выполнения наиболее необходимого разработчикам: сборки, тестирования и запуска их программ. К примеру, виртуальные машины не имеют возможности версионирования, мониторинга, конфигурации, сбора отладочной информации или обнаружения служб

Также Docker позволяет избежать проблем (вплоть до т.н. dependency hell) с зависимостями 
приложения, обеспечить единообразие окружений запуска приложения и, как следствие, упростить 
отладку существующих программных ошибок и предотвращение новых.

####Архитектура, принципы работы Docker
Docker использует архитектуру клиент-сервер. Docker клиент общается с демоном Docker, который берет на себя тяжесть создания, запуска, распределения ваших контейнеров. Оба, клиент и сервер могут работать на одной системе, вы можете подключить клиент к удаленному демону docker. Клиент и сервер общаются через сокет или через RESTful API.  
![Схематичное изображение архитектуры Docker](https://docs.docker.com/article-img/architecture.svg)

#####Docker-демон

Как показано на диаграмме, демон запускается на хост-машине. Пользователь не взаимодействует с 
сервером на прямую, а использует для этого клиент.

#####Docker-клиент

Docker-клиент, программа docker — главный интерфейс к Docker. Она получает команды от пользователя и взаимодействует с docker-демоном.

#####Внутреннее устройство docker

Для работы используется библиотека libcontainer. Так же docker поддерживает традиционный формат контейнеров в Linux c помощью LXC. В будущем Docker, возможно, будет поддерживать другие форматы контейнеров. Например, интегрируясь с BSD Jails или Solaris Zones.

Существуют три необходимых для понимания внутреннего устройства docker компонента:

* образы (images)
* реестр (registries)
* контейнеры

######Образы
Образы — это компонента сборки docker-а.
Docker позволяет легко создавать новые образы, обновлять существующие или скачивать образы, созданные другими людьми.

Образ — это read-only шаблон, из которого создается контейнер. Каждый образ состоит из набора 
уровней. Docker использует union file system для сочетания этих уровней в один образ. Union file 
system позволяет файлам и директориями из разных файловых систем (разным ветвям) прозрачно 
накладываться, создавая когерентную файловую систему.

Одна из причин, по которой docker легковесен — это использование таких уровней. При изменении образа создается новый уровень. Таким образом, добавляется или обновляется только один уровень без необходимости раздавать весь новый образ: раздается только обновление, что позволяет распространять образы проще и быстрее.

В основе каждого образа находится базовый образ. Например, ubuntu, базовый образ Ubuntu, или fedora, базовый образ дистрибутива Fedora. Так есть возможность использовать образы как базу для создания новых образов. Например, при наличии образа apache, можно использовать его как базовый образ для собственных веб-приложений.

Docker образы могут создаться из этих базовых образов, шаги описания для создания этих образов называются инструкциями. Каждая инструкция создает новый образ или уровень. Инструкциями могут быть следующие действия:

* запуск команды
* добавление файла или директории
* создание переменной окружения
* указания что запускать когда запускается контейнер этого образа

Данные инструкции хранятся в файле Dockerfile. При сборке образа Docker считывает Dockerfile, выполняет эти инструкции и возвращает конечный образ.  

######Docker реестр
Реестр — это хранилище docker образов. После создания образа есть возможность опубликовать его приватно либо на публичном реестре Docker Hub.

Docker клиент реализует возможность поиска и использования уже опубликованных образов для создания новых контейнеров.

Docker Hub предоставляет публичные и приватные хранилища образов. Поиск и скачивание образов из публичных хранилищ доступно для всех. Содержимое приватных хранилищ не попадает в результаты поиска.  

######Контейнер
Контейнер состоит из операционной системы, пользовательских файлов и метаданных. Каждый контейнер создается из образа. Этот образ хранит информацию о содержимом контейнера, выполняемый при запуске контейнера процесс и другие конфигурационные данные. Docker образ доступен только для чтения. Когда docker запускает контейнер, он создает уровень для чтения/записи "сверху" образа (используя union file system, как было указано раньше), в котором может быть запущено приложение.

При запуске контейнера с помощью программы docker или с помощью RESTful API, docker клиент отдаёт команду docker демону запустить контейнер.

Более подробное рассмотрение процесса запуска контейнера на примере команды
$ sudo docker run -i -t ubuntu /bin/bash

Клиент запускается с помощью команды docker, с опцией run, которая говорит, что будет запущен новый контейнер. Минимальными требованиями для запуска контейнера являются следующие атрибуты:

* Используемый для создания контейнера образ. В данном случае, ubuntu
* Выполняемую после запуска контейнера команду. В данном случае, /bin/bash

Docker, по порядку, выполняет следующие действия:

* Загружает образ ubuntu: docker проверяет наличие сохранённого образа ubuntu, и при его отсутствии загружает его с Docker Hub. Если же образ есть, то использует его для создания контейнера;
* Создает контейнер: когда образ получен, docker использует его для создания контейнера;
* Инициализирует файловую систему и монтирует read-only уровень: контейнер создан в файловой системе и read-only уровень добавлен образ;
* Инициализирует сетевой интерфейс, который позволяет docker общаться хост-машиной;
* Запускает указанный процесс;
* Обрабатывает и выдает вывод указанного процесса: подключается и сохраняет стандартный вход, вывод и поток ошибок выполняемых команд для обеспечения возможности отслеживания работы приложения.


####Поддерживаемая аппаратная платформа
В настоящий момент для запуска docker-daemon поддерживается только архитектура amd64 (также 
известная как x86_64), что вызывает некоторые неудобства у пользователей 32х-битных систем.  
Однако, существуют способы сборки и запуска docker под 32х-битным окружением.  
В таком случае, разработанные для другой архитектуры образы не будут запускаться, из-за чего 
потеряется некоторая часть плюсов использования docker-registry, но существует возможность 
собирать образы самостоятельно.

####Документация Docker
Существует сборник официальной документации Docker на сайте docs.docker.com, содержащий большое количество разнообразной информации по работе с Docker: от быстрого старта до использования сервиса в условиях работы под управлением виртуальной машины

####Разработка Docker
Docker -- проект с открытым исходным кодом. Код опубликован на [сайте github](https://github.com/docker/docker)  
Таким образом, принять участие в разработке docker может почти каждый.

####Плюсы и минусы
Плюсы и минусы при использовании docker включают в себя как общие для виртуализации на уровне операционной системы плюсы и минусы, так и собственные.

Минусы:

* Дополнительное программное обеспечение для изучения.
* Требует поддержки и определённых особенностей аппаратной платформы (шестидесятичетырёхбитное окружение)
* Создаёт иллюзию защищённости: при наличии программных ошибок в коде docker либо в коде разделения пространств имён ядра Linux могут произойти утечки данных из операционной системы-хоста, которые могут не быть восприняты всерьёз из-за отношения к надёжности данных функций
* Ограниченная обратная совместимость из-за быстрых темпов развития проекта
* Относительно большое количество программных ошибок/недоработок в исходном коде программы, влекущих за собой ряд мешающих работе проблем.

Плюсы:

* Стандартизированное окружение для запускаемых программ
* Возможность использования большого количества готовых образов
* Упрощение разработки и отладки программ
* Активное сообщество

##Вывод
Исходя из описанных выше плюсов и минусов, можно сделать вывод, что контейнерная виртуализация - перспективное направление развития информационных технологий. Оно подходит для решения прикладных задач (например, автоматизации выполнения однотипных действий) и уже с некоторыми оговорками может применяться в production-серверах (например, хостинговая компания Iron.io)  
Очевидно, что в скором времени данная технология прочно займёт нишу разработки и облачного запуска программного обеспечения.

##Используемая литература
1. [Лекция в рамках Лектория CS центра от 15 апреля 2015 года. "Контейнерная виртуализация в Linux." Кирилл Кринкин: CS центр, СПб АУ РАН, СПбГЭТУ](http://open.compscicenter.ru/archive/virtualization-in-linux/)  
2. [Официальная документация (англ.)](https://docs.docker.com/)  
3. [Установка и использование Docker на 32х-битном окружении (англ.)](http://mwhiteley.com/linux-containers/2013/08/31/docker-on-i386.html)  
4. Статьи на сайте habrahabr.ru о Docker: [Поняв Docker](https://habrahabr.ru/post/277699/), [Понимая Docker](https://habrahabr.ru/post/253877/)  
5. [Короткое объяснение некоторых принципов работы Docker (англ.)](http://blog.thoward37.me/articles/where-are-docker-images-stored/)  
6. Документация Linux manpages: namespaces(7), cgroups(7), pid_namespaces(7)
7. [Опыт использования Docker в реальных бизнес-процессах](https://habrahabr.ru/post/247969/)