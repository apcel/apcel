#Перспективы развития архитектуры операционных систем при использовании контейнерной виртуализации
//на примере Docker

##Введение
Немного про архитектуру ОС (и различие между ними для разных семейств?)  

На сегодняшний день Linux — монолитное ядро с поддержкой загружаемых модулей. Драйверы устройств и расширения ядра обычно запускаются в 0-м кольце защиты, с полным доступом к оборудованию. В отличие от обычных монолитных ядер, драйверы устройств легко собираются в виде модулей и загружаются или выгружаются во время работы системы.  
То, что архитектура Linux не является микроядерной, вызвало обширнейшие прения между Линусом Торвальдсом и Эндрю Таненбаумом в конференции comp.os.minix в 1992 г.  
![Архитектура ядра Linux](https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png?uselang=ru)

Архитектура Windows NT имеет модульную структуру и состоит из двух основных уровней — компоненты, работающие в режиме пользователя, и компоненты режима ядра. Программы и подсистемы, работающие в режиме пользователя, имеют ограничения на доступ к системным ресурсам. Режим ядра имеет неограниченный доступ к системной памяти и внешним устройствам. Ядро системы NT называют гибридным ядром или макроядром. Архитектура включает в себя само ядро, уровень аппаратных абстракций (HAL), драйверы и ряд служб (Executives), которые работают в режиме ядра (Kernel-mode drivers) или в пользовательском режиме (User-mode drivers).
![Архитектура ядра Windows](https://upload.wikimedia.org/wikipedia/commons/5/5d/Windows_2000_architecture.svg)



##Основная часть
###Виды виртуализации
####Программная виртуализация
#####Динамическая трансляция
При динамической (бинарной) трансляции проблемные команды гостевой операционной системы перехватываются гипервизором. После того как эти команды заменяются на безопасные, происходит возврат управления гостевой системе.  

#####Паравиртуализация
Паравиртуализация — техника виртуализации, при которой гостевые операционные системы подготавливаются для исполнения в виртуализированной среде, для чего их ядро незначительно модифицируется. Операционная система взаимодействует с программой гипервизора, который предоставляет ей гостевой API, вместо использования напрямую таких ресурсов, как таблица страниц памяти.  
Метод паравиртуализации позволяет добиться более высокой производительности, чем метод динамической трансляции.  
Метод паравиртуализации применим лишь в том случае, если гостевые операционные системы имеют открытые исходные коды, которые можно модифицировать согласно лицензии, или же гипервизор и гостевая операционная система разработаны одним производителем с учётом возможности паравиртуализации гостевой системы (хотя при условии того, что под гипервизором может быть запущен гипервизор более низкого уровня, то и паравиртуализации самого гипервизора).

######Встроенная виртуализация
Преимущества:
* Совместное использование ресурсов несколькими гостевыми операционными системами (каталоги, принтеры и так далее).  
* Удобство интерфейса для окон приложений из разных систем (перекрывающиеся окна приложений, одинаковая минимизация окон, как в хост-системе).  
* При тонкой настройке на аппаратную платформу производительность мало отличается от оригинальной операционной системы. Быстрое переключение между системами (менее одной секунды).  
* Простая процедура обновления гостевой операционной системы.  
* Двухсторонняя виртуализация (приложения одной системы запускаются в другой и наоборот).  

####Аппаратная виртуализация
Преимущества:
* Упрощение разработки программных платформ виртуализации за счет предоставления аппаратных интерфейсов управления и поддержки виртуальных гостевых систем. Это уменьшает трудоемкость и время на разработку систем виртуализации.  
* Возможность увеличения быстродействия платформ виртуализации. Управление виртуальными гостевыми системами осуществляет напрямую небольшой промежуточный слой программного обеспечения, гипервизор, что дает увеличение быстродействия.  
* Улучшается защищённость, появляется возможность переключения между несколькими запущенными независимыми платформами виртуализации на аппаратном уровне. Каждая из виртуальных машин может работать независимо, в своем пространстве аппаратных ресурсов, полностью изолированно друг от друга. Это позволяет устранить потери быстродействия на поддержание хостовой платформы и увеличить защищенность.  
* Гостевая система становится не привязана к архитектуре хостовой платформы и к реализации платформы виртуализации. Технология аппаратной виртуализации делает возможным запуск 64-битных гостевых систем на 32-битных хостовых системах (с 32-битными средами виртуализации на хостах).  


####Виртуализация на уровне операционной системы
Виртуализация на уровне операционной системы позволяет запускать изолированные и безопасные виртуальные машины на одном физическом узле, но не позволяет запускать операционные системы с ядрами, отличными от типа ядра базовой операционной системы. При виртуализации на уровне операционной системы не существует отдельного слоя гипервизора. Вместо этого сама хостовая операционная система отвечает за разделение аппаратных ресурсов между несколькими виртуальными машинами и поддержку их независимости друг от друга.  

###Принципы разделения пространств (namespaces, cgroups)
####Namespaces
Согласно официальной документации ядра Linux, размещённой на сайте kernel.org,  

    A namespace wraps a global system resource in an abstraction that
    makes it appear to the processes within the namespace that they have
    their own isolated instance of the global resource.  Changes to the
    global resource are visible to other processes that are members of
    the namespace, but are invisible to other processes.  One use of
    namespaces is to implement containers.

    Linux provides the following namespaces:

        Namespace   Constant          Isolates
        Cgroup      CLONE_NEWCGROUP   Cgroup root directory
        IPC         CLONE_NEWIPC      System V IPC, POSIX message queues
        Network     CLONE_NEWNET      Network devices, stacks, ports, etc.
        Mount       CLONE_NEWNS       Mount points
        PID         CLONE_NEWPID      Process IDs
        User        CLONE_NEWUSER     User and group IDs
        UTS         CLONE_NEWUTS      Hostname and NIS domain name

То есть, упрощённо, namespaces позволяют ограничивать видимость некоторых глобальных ресурсов программами. Например, идентификаторов процессов (PID), что позволяет разделять области видимости для процессов, которым не требуется больше: к примеру, некоторый пакетный менеджер не требует для нормальной работы доступа к запущенному веб-браузеру. Но, в случае использования злоумышленником некоторой уязвимости, он мог бы получить к нему доступ.  
####Cgroups
Cgroups похожи на namespaces по описанию, но относятся больше к физическим ресурсам компьютера.
Согласно документации,  

    A cgroup is a collection of processes that are bound to a set of
    limits or parameters defined via the cgroup filesystem.

    A subsystem is a kernel component that modifies the behavior of the
    processes in a cgroup.  Various subsystems have been implemented,
    making it possible to do things such as limiting the amount of CPU
    time and memory available to a cgroup, accounting for the CPU time
    used by a cgroup, and freezing and resuming execution of the
    processes in a cgroup.  Subsystems are sometimes also known as
    resource controllers (or simply, controllers).

    The cgroups for a subsystem are arranged in a hierarchy.  This
    hierarchy is defined by creating, removing, and renaming
    subdirectories within the cgroup filesystem.  At each level of the
    hierarchy, attributes (e.g., limits) can be defined; these attributes
    may govern or propagate to child cgroups and and their descendants in
    the hierarchy.

Таким образом, данная технология позволяет ограничить используемые процессом (или группой процессов) ресурсы вплоть до полной остановки группы (контроллер _freezer_), включая её иерархических "потомков", сообщить приложению меньшее количество оперативной памяти/процессорных ядер процессора, чем на самом деле присутствует в системе, тем самым оставив большее количество ресурсов прочим приложениям, и так далее (см. `man 7 cgroups`, раздел subsystems, для большей информации)

###Принципы контейнерной виртуализации
    Контейнер – это метафора. В морских и железнодорожных перевозках буквальные контейнеры 
    используются потому, что благодаря стандартизованной форме и размеру их удобно складывать 
    большими штабелями. Точно так же виртуальный контейнер позволяет взять приложение (это может 
    быть почтовый клиент, блогерская платформа, что угодно) и все необходимые для него 
    инструменты и упаковать в стандартную виртуальную «коробку». Затем такая коробка загружается 
    на сервер или дата-центр, будь то собственный или сторонний, и ее содержимое везде работает 
    абсолютно одинаково вне зависимости от среды, инфраструктуры и прочих условий. Работа 
    приложения становится самодостаточной и полностью отделяется от окружающей реализации. 
    Отсюда название и «контейнер» – от self-contained, «самодостаточный».
![Иллюстрация на тему возможных применений контейнеров](http://img.scoop.it/tImVj_1Pbqv0HJDyMWTmBbnTzqrqzN7Y9aBZTaXoQ8Q=)  
![И ещё одна. Эта лучше](http://image.slidesharecdn.com/dockerwithopenstack-141022075719-conversion-gate02/95/docker-with-openstack-11-638.jpg?cb=1413964733)  

Контейнерная виртуализация относится к виртуализации на уровне операционной системы и поэтому требует поддержки данной технологии ядром хост-ОС. В настоящий момент лучше всего для этого подходит при достаточной распространённости и известности ядро GNU/Linux благодаря поддержке описанных выше технологий.  

###Docker как наиболее известная система управления контейнерами
В настоящий момент данная отрасль довольно активно развивается. Существует немалое количество ПО для создания и управления контейнерами. Например, OpenVZ и LXC.  
Наиболее известен Docker, про который также говорится "Docker: container revolution".  

    Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в 
    среде виртуализации на уровне операционной системы, например LXC. Позволяет «упаковать» 
    приложение со всем его окружением и зависимостями в контейнер, который может быть перенесён 
    на любой Linux-системе с поддержкой cgroups в ядре, а также предоставляет среду по 
    управлению контейнерами.

    Разрабатывается и поддерживается одноимённой компанией-стартапом, распространяется как 
    свободное программное обеспечение под лицензией Apache 2.0. Написан на языке Go.

Docker позиционируется как инструмент для упрощения разработки, поддержки и конфигурации программного обеспечения. Плюсы использования Docker:
  * *Размер*: Виртуальные машины занимают довольно большое количество дискового пространства, что делает их не очень удобными для транспортировки и хранения.
  * *Быстродействие*: Запуск виртуальной машины требует значительных ресурсов оперативной памяти и процессора, что делает их непрактичными во многих сценариях использования.
  * *Переносимость*: Разнообразные окружения виртуальных машин не очень хорошо взаимодействуют между собой. Несмотря на существование средств конвертации, они довольно ограниченны и добавляют ещё большее использование ресурсов.
  * *Аппаратно-ориентированность*: Виртуальные машины были разработаны не для разработчиков, а для механизаторов _(как это перевести? - прим. авт.)_. В результате, они предлагают довольно скудный инструментарий для выполнения наиболее необходимого разработчикам: сборки, тестирования и запуска их программ. К примеру, виртуальные машины не имеют возможности версионирования, мониторинга, конфигурации, сбора отладочной информации или обнаружения служб

Также Docker позволяет избежать проблем (вплоть до т.н. dependency hell) с зависимостями 
приложения, обеспечить единообразие окружений запуска приложения и, как следствие, упростить 
отладку существующих программных ошибок и предотвращение новых.

####Архитектура, принципы работы Docker
Docker использует архитектуру клиент-сервер. Docker клиент общается с демоном Docker, который берет на себя тяжесть создания, запуска, распределения ваших контейнеров. Оба, клиент и сервер могут работать на одной системе, вы можете подключить клиент к удаленному демону docker. Клиент и сервер общаются через сокет или через RESTful API.  
![Схематичное изображение архитектуры Docker](https://docs.docker.com/article-img/architecture.svg)

#####Docker-демон

Как показано на диаграмме, демон запускается на хост-машине. Пользователь не взаимодействует с 
сервером на прямую, а использует для этого клиент.

#####Docker-клиент

Docker-клиент, программа docker — главный интерфейс к Docker. Она получает команды от пользователя и взаимодействует с docker-демоном.

#####Внутреннее устройство docker

Для работы используется библиотека libcontainer. Так же docker поддерживает традиционный формат контейнеров в Linux c помощью LXC. В будущем Docker, возможно, будет поддерживать другие форматы контейнеров. Например, интегрируясь с BSD Jails или Solaris Zones.

Существуют три необходимых для понимания внутреннего устройства docker компонента:
* образы (images)
* реестр (registries)
* контейнеры
######Образы
Образы

Образы — это компонента сборки docker-а.
Docker позволяет легко создавать новые образы, обновлять существующие или скачивать образы, созданные другими людьми.

Образ — это read-only шаблон, из которого создается контейнер. Каждый образ состоит из набора 
уровней. Docker использует union file system для сочетания этих уровней в один образ. Union file 
system позволяет файлам и директориями из разных файловых систем (разным ветвям) прозрачно 
накладываться, создавая когерентную файловую систему.

Одна из причин, по которой docker легковесен — это использование таких уровней. При изменении образа создается новый уровень. Таким образом, добавляется или обновляется только один уровень без необходимости раздавать весь новый образ: раздается только обновление, что позволяет распространять образы проще и быстрее.

В основе каждого образа находится базовый образ. Например, ubuntu, базовый образ Ubuntu, или fedora, базовый образ дистрибутива Fedora. Так есть возможность использовать образы как базу для создания новых образов. Например, при наличии образа apache, можно использовать его как базовый образ для собственных веб-приложений.

Docker образы могут создаться из этих базовых образов, шаги описания для создания этих образов называются инструкциями. Каждая инструкция создает новый образ или уровень. Инструкциями могут быть следующие действия:

* запуск команды
* добавление файла или директории
* создание переменной окружения
* указания что запускать когда запускается контейнер этого образа

Данные инструкции хранятся в файле Dockerfile. При сборке образа Docker считывает Dockerfile, выполняет эти инструкции и возвращает конечный образ.
######Docker реестр
Реестр — это хранилище docker образов. После создания образа есть возможность опубликовать его приватно либо на публичном реестре Docker Hub.

Docker клиент реализует возможность поиска и использования уже опубликованных образов для создания новых контейнеров.

Docker Hub предоставляет публичные и приватные хранилища образов. Поиск и скачивание образов из публичных хранилищ доступно для всех. Содержимое приватных хранилищ не попадает в результаты поиска.
######Контейнер

Контейнер состоит из операционной системы, пользовательских файлов и метаданных. Каждый контейнер создается из образа. Этот образ хранит информацию о содержимом контейнера, выполняемый при запуске контейнера процесс и другие конфигурационные данные. Docker образ доступен только для чтения. Когда docker запускает контейнер, он создает уровень для чтения/записи "сверху" образа (используя union file system, как было указано раньше), в котором может быть запущено приложение.

При запуске контейнера с помощью программы docker или с помощью RESTful API, docker клиент отдаёт команду docker демону запустить контейнер.

Более подробное рассмотрение процесса запуска контейнера на примере команды
$ sudo docker run -i -t ubuntu /bin/bash

Клиент запускается с помощью команды docker, с опцией run, которая говорит, что будет запущен новый контейнер. Минимальными требованиями для запуска контейнера являются следующие атрибуты:

* Используемый для создания контейнера образ. В данном случае, ubuntu
* Выполняемую после запуска контейнера команду. В данном случае, /bin/bash

Docker, по порядку, выполняет следующие действия:

* Загружает образ ubuntu: docker проверяет наличие сохранённого образа ubuntu, и при его отсутствии загружает его с Docker Hub. Если же образ есть, то использует его для создания контейнера;
* Создает контейнер: когда образ получен, docker использует его для создания контейнера;
* Инициализирует файловую систему и монтирует read-only уровень: контейнер создан в файловой системе и read-only уровень добавлен образ;
* Инициализирует сетевой интерфейс, который позволяет docker общаться хост-машиной;
* Запускает указанный процесс;
* Обрабатывает и выдает вывод указанного процесса: подключается и сохраняет стандартный вход, вывод и поток ошибок выполняемых команд для обеспечения возможности отслеживания работы приложения.


####Поддерживаемая аппаратная платформа
В настоящий момент для запуска docker-daemon поддерживается только архитектура amd64 (также 
известная как x86_64), что вызывает некоторые неудобства у пользователей 32х-битных систем.  
Однако, существуют способы сборки и запуска docker под 32х-битным окружением.  
В таком случае, разработанные для другой архитектуры образы не будут запускаться, из-за чего 
потеряется некоторая часть плюсов использования docker-registry, но существует возможность 
собирать образы самостоятельно.

####Документация Docker
Существует сборник официальной документации Docker на сайте docs.docker.com, содержащий большое количество разнообразной информации по работе с Docker: от быстрого старта до использования сервиса в условиях работы под управлением виртуальной машины

####Разработка Docker
Контрибьют! Открывайте issue на гитхабе, правьте исходники и радуйтесь!  

####Плюсы и минусы
//важная фигня, но, вероятно, и без того выйдет много  
__-__Дыры в ядре, лол.  
__+__Бла-бла-бла, вы всегда можете взять что-то и переместить, бла-бла, контейнеры, бла, отладка-разработка-PaaS?  


##Вывод
//Перспективы применения  
Исходя из описанных выше плюсов и минусов, можно сделать вывод, что контейнерная виртуализация - перспективное направление развития информационных технологий. Оно подходит для решения прикладных задач (например, автоматизации выполнения однотипных действий) и уже может применяться в production-серверах (примеры)  

##Используемая литература
1. [Лекция в рамках Лектория CS центра от 15 апреля 2015 года. "Контейнерная виртуализация в Linux." Кирилл Кринкин: CS центр, СПб АУ РАН, СПбГЭТУ](http://open.compscicenter.ru/archive/virtualization-in-linux/)  
2. [Официальная документация (англ.)](https://docs.docker.com/)  
3. [Установка Docker на 32х-битной системе (англ.)](http://mwhiteley.com/linux-containers/2013/08/31/docker-on-i386.html)  
4. Примеры статей на сайте habrahabr.ru о Docker: [Поняв Docker](https://habrahabr.ru/post/277699/), [Понимая Docker](https://habrahabr.ru/post/253877/)  
5. [Короткое объяснение некоторых принципов работы Docker (англ.)](http://blog.thoward37.me/articles/where-are-docker-images-stored/)  
6. Документация Linux manpages: namespaces(7)